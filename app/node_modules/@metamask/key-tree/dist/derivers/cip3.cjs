"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildKey = exports.derivePublicKey = exports.deriveChainCode = exports.derivePrivateKey = exports.getKeyExtension = exports.add = exports.mod2Pow256 = exports.trunc28Mul8 = exports.padEnd32Bytes = exports.bigIntToBytes = exports.bytesToBigInt = exports.toReversed = void 0;
const utils_1 = require("@metamask/utils");
const shared_1 = require("./shared.cjs");
const constants_1 = require("../constants.cjs");
const curves_1 = require("../curves/index.cjs");
const SLIP10Node_1 = require("../SLIP10Node.cjs");
const utils_2 = require("../utils.cjs");
/**
 * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.
 *
 * CIP-3 defines standards for deriving keys on Cardano.
 *
 * Key attributes.
 * - Root/Master key is derived from entropy, not seed. For this implementation we work with Icarus standard as it is the most widely used.
 * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.
 *
 * - HD node consists of a 64 byte private key, 32 byte public key and 32 byte chain code.
 * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.
 *
 * - For derivation of BIP32 HD nodes, it uses modified version called BIP32-Ed25519.
 * - See https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
 */
/**
 * Reverses the order of bytes in a Uint8Array.
 *
 * Native BigInt uses big-endian. Since cip3(bip32Edd25519) uses little-endian.
 * We need to reverse the bytes and have separate functions for bigIntToBytes and bytesToBigInt.
 * .slice() is used just to make a copy of the array.
 *
 * @param bytes - The input Uint8Array.
 * @returns A new Uint8Array with the bytes in reversed order.
 */
const toReversed = (bytes) => bytes.slice().reverse();
exports.toReversed = toReversed;
/**
 * Converts an array of bytes to a BigInt.
 *
 * @param bytes - The array of bytes to convert.
 * @returns The BigInt representation of the bytes.
 */
const bytesToBigInt = (bytes) => {
    const reversed = (0, exports.toReversed)(bytes);
    const bytesInHex = (0, utils_1.bytesToHex)(reversed);
    return BigInt(bytesInHex);
};
exports.bytesToBigInt = bytesToBigInt;
/**
 * Converts a BigInt to a byte array.
 *
 * @param bigInt - The BigInt to convert.
 * @returns The byte array representation of the BigInt.
 */
const bigIntToBytes = (bigInt) => {
    const hexadecimal = bigInt.toString(16);
    return (0, exports.toReversed)((0, utils_1.hexToBytes)(hexadecimal));
};
exports.bigIntToBytes = bigIntToBytes;
/**
 * Pads end of the given bytes array with zeros to a length of 32 bytes.
 *
 * @param bytes - The bytes array to pad.
 * @returns The padded bytes array.
 */
const padEnd32Bytes = (bytes) => {
    return (0, utils_1.concatBytes)([
        bytes,
        new Uint8Array(Math.max(32 - bytes.length, 0)).fill(0),
    ]);
};
exports.padEnd32Bytes = padEnd32Bytes;
/**
 * Truncates to first 28 bytes and multiplies by 8.
 *
 * @param bytes - Little-Endian big number in bytes.
 * @returns PadEnd32Bytes(left[0, 28] * 8)).
 */
const trunc28Mul8 = (bytes) => {
    const truncLeftMul8 = (0, exports.bytesToBigInt)(bytes.slice(0, 28)) * BigInt(8);
    return (0, exports.padEnd32Bytes)((0, exports.bigIntToBytes)(truncLeftMul8));
};
exports.trunc28Mul8 = trunc28Mul8;
/**
 * Does module 2^256.
 *
 * @param bytes - Little-Endian big number in bytes.
 * @returns PadEnd32Bytes(mod(bytes, 2^256))).
 */
const mod2Pow256 = (bytes) => {
    return (0, exports.padEnd32Bytes)((0, exports.bigIntToBytes)((0, curves_1.mod)((0, exports.bytesToBigInt)(bytes), BigInt(2) ** BigInt(256))));
};
exports.mod2Pow256 = mod2Pow256;
/**
 * Adds the left to the right.
 *
 * @param left - Left hand side Little-Endian big number.
 * @param right - Right hand side Little-Endian big number.
 * @returns PadEnd32Bytes(left + right).
 */
const add = (left, right) => {
    const added = (0, exports.bytesToBigInt)(left) + (0, exports.bytesToBigInt)(right);
    return (0, exports.padEnd32Bytes)((0, exports.bigIntToBytes)(added)).slice(0, 32);
};
exports.add = add;
/**
 * Concat tag, key and childIndex.
 *
 * @param tag - Key specific tag.
 * @param key - Key.
 * @param childIndex - Child index.
 * @returns PadEnd32Bytes(left + right).
 */
const getKeyExtension = (tag, key, childIndex) => {
    return (0, utils_1.concatBytes)([
        new Uint8Array([tag]),
        key,
        (0, utils_2.numberToUint32)(childIndex, true),
    ]);
};
exports.getKeyExtension = getKeyExtension;
const Z_TAGS = {
    normal: 2,
    hardened: 0,
};
/**
 * Derive a private child key.
 *
 * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in
 * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
 *
 * @param options - The parameters for deriving a child key.
 * @param options.parentNode - The parent node containing private key, chain
 * code, and public key.
 * @param options.childIndex - The index of the child key.
 * @param options.isHardened - Indicates if the child key is hardened.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The derived child key.
 */
const derivePrivateKey = async ({ parentNode, childIndex, isHardened }, cryptographicFunctions) => {
    // extension = i >= 2^31 ? (0x00||kp||i) : (0x02||Ap||i)
    const extension = isHardened
        ? (0, exports.getKeyExtension)(Z_TAGS.hardened, parentNode.privateKeyBytes, childIndex + constants_1.BIP_32_HARDENED_OFFSET)
        : (0, exports.getKeyExtension)(Z_TAGS.normal, parentNode.publicKeyBytes, childIndex);
    // entropy = Fcp(extension)
    const entropy = await (0, shared_1.generateEntropy)({
        chainCode: parentNode.chainCodeBytes,
        extension,
    }, cryptographicFunctions);
    const zl = entropy.subarray(0, 32);
    const zr = entropy.subarray(32);
    const parentKl = parentNode.privateKeyBytes.subarray(0, 32);
    const parentKr = parentNode.privateKeyBytes.subarray(32);
    // 8[ZL] + kPL
    const childKl = (0, exports.add)((0, exports.trunc28Mul8)(zl), parentKl);
    // ZR + kPR
    const childKr = (0, exports.add)(zr, parentKr);
    return (0, utils_1.concatBytes)([childKl, childKr]);
};
exports.derivePrivateKey = derivePrivateKey;
const CHAIN_CODE_TAGS = {
    normal: 3,
    hardened: 1,
};
/**
 * Derive a child chainCode.
 *
 * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in
 * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
 *
 * @param options - The parameters for deriving a child chainCode.
 * @param options.parentNode - The parent node containing optionally a private
 * key, chain code, and public key.
 * @param options.childIndex - The index of the child key.
 * @param options.isHardened - Indicates if the child key is hardened.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The derived child chainCode.
 */
const deriveChainCode = async ({ parentNode, childIndex, isHardened, }, cryptographicFunctions) => {
    // extension = i >= 2^31 ? (0x01||kp||i) : (0x03||Ap||i)
    const extension = isHardened
        ? (0, exports.getKeyExtension)(CHAIN_CODE_TAGS.hardened, parentNode.privateKeyBytes, childIndex + constants_1.BIP_32_HARDENED_OFFSET)
        : (0, exports.getKeyExtension)(CHAIN_CODE_TAGS.normal, parentNode.publicKeyBytes, childIndex);
    // entropy = Fcp(extension)
    const entropy = await (0, shared_1.generateEntropy)({
        chainCode: parentNode.chainCodeBytes,
        extension,
    }, cryptographicFunctions);
    return entropy.subarray(32);
};
exports.deriveChainCode = deriveChainCode;
const PUBLIC_KEY_TAGS = {
    normal: 2,
};
/**
 * Derive a public key.
 *
 * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in
 * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
 *
 * @param options - The parameters for deriving a child public key.
 * @param options.parentNode - The parent node containing chain code, and public key.
 * @param options.childIndex - The index of the child key.
 * @param options.curve - Derivation curve.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The derived child public key.
 */
const derivePublicKey = async ({ parentNode, childIndex, curve }, cryptographicFunctions) => {
    // extension = (0x02||Ap||i)
    const extension = (0, exports.getKeyExtension)(PUBLIC_KEY_TAGS.normal, parentNode.publicKeyBytes, childIndex);
    // entropy = Fcp(extension)
    const entropy = await (0, shared_1.generateEntropy)({
        chainCode: parentNode.chainCodeBytes,
        extension,
    }, cryptographicFunctions);
    const zl = entropy.slice(0, 32);
    // right = [8ZL] * B
    const right = curve.getPublicKey(
    // [8ZL]
    (0, exports.trunc28Mul8)(zl));
    // Ai = AP + [8ZL]B,
    return curve.publicAdd(parentNode.publicKeyBytes, right);
};
exports.derivePublicKey = derivePublicKey;
/**
 * Derive a SLIP-10 child key with a given path from a parent key.
 *
 * @param options - The options for deriving a child key.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns SLIP10Node.
 */
async function deriveChildKey(options, cryptographicFunctions) {
    const { curve, node, path } = options;
    (0, shared_1.validateNode)(node);
    const { childIndex, isHardened } = (0, shared_1.getValidatedPath)(path, node, curve);
    if (curve.name !== 'ed25519Bip32' || !node) {
        throw new Error('Unsupported curve: Only ed25519Bip32 is supported by CIP3.');
    }
    const actualChildIndex = childIndex + (isHardened ? constants_1.BIP_32_HARDENED_OFFSET : 0);
    const { privateKeyBytes, chainCodeBytes, publicKeyBytes, masterFingerprint, depth, fingerprint: parentFingerprint, } = node;
    if (privateKeyBytes) {
        const parentNode = {
            privateKeyBytes,
            chainCodeBytes,
            publicKeyBytes,
        };
        const privateKey = await (0, exports.derivePrivateKey)({
            parentNode,
            childIndex,
            isHardened,
        }, cryptographicFunctions);
        const chainCode = await (0, exports.deriveChainCode)({
            parentNode,
            childIndex,
            isHardened,
        }, cryptographicFunctions);
        return SLIP10Node_1.SLIP10Node.fromExtendedKey({
            privateKey: (0, utils_1.bytesToHex)(privateKey),
            chainCode: (0, utils_1.bytesToHex)(chainCode),
            masterFingerprint,
            depth: depth + 1,
            parentFingerprint,
            index: actualChildIndex,
            curve: curve.name,
        }, cryptographicFunctions);
    }
    (0, utils_1.assert)(!isHardened, 'Invalid parameters: Cannot derive hardened child keys without a private key.');
    const parentNode = {
        chainCodeBytes,
        publicKeyBytes,
    };
    const publicKey = await (0, exports.derivePublicKey)({
        parentNode,
        childIndex,
        isHardened: false,
        curve,
    }, cryptographicFunctions);
    const chainCode = await (0, exports.deriveChainCode)({
        parentNode,
        childIndex,
        isHardened: false,
    }, cryptographicFunctions);
    return SLIP10Node_1.SLIP10Node.fromExtendedKey({
        publicKey: (0, utils_1.bytesToHex)(publicKey),
        chainCode: (0, utils_1.bytesToHex)(chainCode),
        masterFingerprint,
        depth: depth + 1,
        parentFingerprint,
        index: actualChildIndex,
        curve: curve.name,
    }, cryptographicFunctions);
}
exports.deriveChildKey = deriveChildKey;
//# sourceMappingURL=cip3.cjs.map