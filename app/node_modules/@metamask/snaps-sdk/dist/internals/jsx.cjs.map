{"version":3,"file":"jsx.cjs","sourceRoot":"","sources":["../../src/internals/jsx.ts"],"names":[],"mappings":";;;AAcA,2CAAkC;AAyElC;;;;;;;GAOG;AACH,SAAgB,SAAS,CACvB,OAAoC;IAEpC,OAAO,IAAA,eAAK,EAAC,OAAO,CAGnB,CAAC;AACJ,CAAC;AAPD,8BAOC","sourcesContent":["import type {\n  AnyStruct,\n  EnumSchema,\n  Infer,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  Struct,\n  UnionToIntersection,\n} from '@metamask/superstruct';\nimport type { CaipChainId } from '@metamask/utils';\n\nimport { union } from './structs';\nimport type { EmptyObject } from '../types';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> =\n  IsUnion<Type> extends true\n    ? null\n    : [Type] extends [EmptyObject]\n      ? EmptyObject\n      : [Type] extends [string | undefined | null]\n        ? [Type] extends [`0x${string}`]\n          ? null\n          : [Type] extends [CaipChainId]\n            ? null\n            : [Type] extends [IsMatch<Type, string | undefined | null>]\n              ? null\n              : [Type] extends [IsUnion<Type>]\n                ? EnumSchema<Type>\n                : Type\n        : [Type] extends [number | undefined | null]\n          ? [Type] extends [IsMatch<Type, number | undefined | null>]\n            ? null\n            : [Type] extends [IsUnion<Type>]\n              ? EnumSchema<Type>\n              : Type\n          : [Type] extends [boolean]\n            ? [Type] extends [IsExactMatch<Type, boolean>]\n              ? null\n              : Type\n            : Type extends\n                  | bigint\n                  | symbol\n                  | undefined\n                  | null\n                  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n                  | Function\n                  | Date\n                  | Error\n                  | RegExp\n                  | Map<any, any>\n                  | WeakMap<any, any>\n                  | Set<any>\n                  | WeakSet<any>\n                  | Promise<any>\n              ? null\n              : Type extends (infer E)[]\n                ? Type extends IsTuple<Type>\n                  ? null\n                  : Struct<E>\n                : Type extends object\n                  ? Type extends IsRecord<Type>\n                    ? null\n                    : {\n                        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n                      }\n                  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n"]}