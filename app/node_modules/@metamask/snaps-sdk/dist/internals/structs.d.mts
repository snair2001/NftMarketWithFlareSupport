import type { AnyStruct, Infer, InferStructTuple } from "@metamask/superstruct";
import { Struct } from "@metamask/superstruct";
import type { EnumToUnion } from "./helpers.mjs";
/**
 * A wrapper of `superstruct`'s `literal` struct that also defines the name of
 * the struct as the literal value.
 *
 * This is useful for improving the error messages returned by `superstruct`.
 * For example, instead of returning an error like:
 *
 * ```
 * Expected the value to satisfy a union of `literal | literal`, but received: \"baz\"
 * ```
 *
 * This struct will return an error like:
 *
 * ```
 * Expected the value to satisfy a union of `"foo" | "bar"`, but received: \"baz\"
 * ```
 *
 * @param value - The literal value.
 * @returns The `superstruct` struct, which validates that the value is equal
 * to the literal value.
 */
export declare function literal<Type extends string | number | boolean>(value: Type): Struct<Type, null>;
/**
 * A wrapper of `superstruct`'s `union` struct that also defines the schema as
 * the union of the schemas of the structs.
 *
 * This is useful for improving the error messages returned by `superstruct`.
 *
 * @param structs - The structs to union.
 * @param structs."0" - The first struct.
 * @param structs."1" - The remaining structs.
 * @returns The `superstruct` struct, which validates that the value satisfies
 * one of the structs.
 */
export declare function union<Head extends AnyStruct, Tail extends AnyStruct[]>([head, ...tail]: [head: Head, ...tail: Tail]): Struct<Infer<Head> | InferStructTuple<Tail>[number], [
    head: Head,
    ...tail: Tail
]>;
/**
 * Superstruct struct for validating an enum value. This allows using both the
 * enum string values and the enum itself as values.
 *
 * @param constant - The enum to validate against.
 * @returns The superstruct struct.
 */
export declare function enumValue<Type extends string>(constant: Type): Struct<EnumToUnion<Type>, null>;
/**
 * Create a custom union struct that validates exclusively based on a `type` field.
 *
 * This should improve error messaging for unions with many structs in them.
 *
 * @param structs - The structs to union.
 * @returns The `superstruct` struct, which validates that the value satisfies
 * one of the structs.
 */
export declare function typedUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(structs: [head: Head, ...tail: Tail]): Struct<Infer<Head> | InferStructTuple<Tail>[number], null>;
/**
 * Create a custom union struct that uses a `selector` function for choosing
 * the validation path.
 *
 * @param selector - The selector function choosing the struct to validate with.
 * @returns The `superstruct` struct, which validates that the value satisfies
 * one of the structs.
 */
export declare function selectiveUnion<Selector extends (value: any) => AnyStruct>(selector: Selector): Struct<Infer<ReturnType<Selector>>, null>;
/**
 * Refine a struct to be a non-empty record and disallows usage of arrays.
 *
 * @param Key - The struct for the record key.
 * @param Value - The struct for the record value.
 * @returns The refined struct.
 */
export declare function nonEmptyRecord<Key extends string, Value>(Key: Struct<Key>, Value: Struct<Value>): Struct<Record<Key, Value>, null>;
//# sourceMappingURL=structs.d.mts.map