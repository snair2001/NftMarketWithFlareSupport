"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildKey = exports.publicKeyToEthAddress = exports.privateKeyToEthAddress = void 0;
const utils_1 = require("@metamask/utils");
const shared_1 = require("./shared.cjs");
const constants_1 = require("../constants.cjs");
const cryptography_1 = require("../cryptography.cjs");
const curves_1 = require("../curves/index.cjs");
const utils_2 = require("../utils.cjs");
/**
 * Converts a BIP-32 private key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` private key bytes to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function privateKeyToEthAddress(key) {
    (0, utils_1.assert)(key instanceof Uint8Array && (0, utils_2.isValidBytesKey)(key, constants_1.BYTES_KEY_LENGTH), 'Invalid key: The key must be a 32-byte, non-zero Uint8Array.');
    const publicKey = curves_1.secp256k1.getPublicKey(key, false);
    return publicKeyToEthAddress(publicKey);
}
exports.privateKeyToEthAddress = privateKeyToEthAddress;
/**
 * Converts a BIP-32 public key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` public key bytes to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function publicKeyToEthAddress(key) {
    (0, utils_1.assert)(key instanceof Uint8Array &&
        (0, utils_2.isValidBytesKey)(key, curves_1.secp256k1.publicKeyLength), 'Invalid key: The key must be a 65-byte, non-zero Uint8Array.');
    return (0, cryptography_1.keccak256)(key.slice(1)).slice(-20);
}
exports.publicKeyToEthAddress = publicKeyToEthAddress;
/**
 * Derive a BIP-32 child key with a given path from a parent key.
 *
 * @param options - The options for deriving a child key.
 * @param options.path - The derivation path part to derive.
 * @param options.node - The node to derive from.
 * @param options.curve - The curve to use for derivation.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The derived child key as a {@link SLIP10Node}.
 */
async function deriveChildKey(options, cryptographicFunctions) {
    (0, utils_1.assert)(options.curve.name === 'secp256k1', 'Invalid curve: Only secp256k1 is supported by BIP-32.');
    return (0, shared_1.deriveChildKey)(options, handleError, cryptographicFunctions);
}
exports.deriveChildKey = deriveChildKey;
/**
 * Handles an error thrown during derivation by incrementing the child index
 * and retrying.
 *
 * @param _ - The error that was thrown.
 * @param options - The options for deriving a child key.
 * @param cryptographicFunctions - The cryptographic functions to use. If
 * provided, these will be used instead of the built-in implementations.
 * @returns The options for deriving a child key with the child index
 * incremented by one.
 */
async function handleError(_, options, cryptographicFunctions) {
    const { childIndex, privateKey, publicKey, isHardened, chainCode, curve } = options;
    (0, utils_2.validateBIP32Index)(childIndex + 1);
    if (privateKey) {
        const secretExtension = await (0, shared_1.deriveSecretExtension)({
            privateKey,
            publicKey: curve.compressPublicKey(publicKey),
            childIndex: childIndex + 1,
            isHardened,
            curve,
        });
        const newEntropy = await (0, shared_1.generateEntropy)({
            chainCode,
            extension: secretExtension,
        }, cryptographicFunctions);
        return {
            ...options,
            childIndex: childIndex + 1,
            entropy: newEntropy,
        };
    }
    const publicExtension = (0, shared_1.derivePublicExtension)({
        parentPublicKey: publicKey,
        childIndex: childIndex + 1,
    });
    const newEntropy = await (0, shared_1.generateEntropy)({
        chainCode,
        extension: publicExtension,
    });
    return {
        ...options,
        childIndex: childIndex + 1,
        entropy: newEntropy,
    };
}
//# sourceMappingURL=bip32.cjs.map