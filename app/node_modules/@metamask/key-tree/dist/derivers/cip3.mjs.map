{"version":3,"file":"cip3.mjs","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert, bytesToHex, concatBytes, hexToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { generateEntropy, getValidatedPath, validateNode } from './shared';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { type Curve, mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\n\n/**\n * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.\n *\n * CIP-3 defines standards for deriving keys on Cardano.\n *\n * Key attributes.\n * - Root/Master key is derived from entropy, not seed. For this implementation we work with Icarus standard as it is the most widely used.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n *\n * - HD node consists of a 64 byte private key, 32 byte public key and 32 byte chain code.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * - For derivation of BIP32 HD nodes, it uses modified version called BIP32-Ed25519.\n * - See https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n */\n\n/**\n * Reverses the order of bytes in a Uint8Array.\n *\n * Native BigInt uses big-endian. Since cip3(bip32Edd25519) uses little-endian.\n * We need to reverse the bytes and have separate functions for bigIntToBytes and bytesToBigInt.\n * .slice() is used just to make a copy of the array.\n *\n * @param bytes - The input Uint8Array.\n * @returns A new Uint8Array with the bytes in reversed order.\n */\nexport const toReversed = (bytes: Uint8Array): Uint8Array =>\n  bytes.slice().reverse();\n\n/**\n * Converts an array of bytes to a BigInt.\n *\n * @param bytes - The array of bytes to convert.\n * @returns The BigInt representation of the bytes.\n */\nexport const bytesToBigInt = (bytes: Uint8Array): bigint => {\n  const reversed = toReversed(bytes);\n  const bytesInHex = bytesToHex(reversed);\n  return BigInt(bytesInHex);\n};\n\n/**\n * Converts a BigInt to a byte array.\n *\n * @param bigInt - The BigInt to convert.\n * @returns The byte array representation of the BigInt.\n */\nexport const bigIntToBytes = (bigInt: bigint): Uint8Array => {\n  const hexadecimal = bigInt.toString(16);\n  return toReversed(hexToBytes(hexadecimal));\n};\n\n/**\n * Pads end of the given bytes array with zeros to a length of 32 bytes.\n *\n * @param bytes - The bytes array to pad.\n * @returns The padded bytes array.\n */\nexport const padEnd32Bytes = (bytes: Uint8Array): Uint8Array => {\n  return concatBytes([\n    bytes,\n    new Uint8Array(Math.max(32 - bytes.length, 0)).fill(0),\n  ]);\n};\n\n/**\n * Truncates to first 28 bytes and multiplies by 8.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(left[0, 28] * 8)).\n */\nexport const trunc28Mul8 = (bytes: Uint8Array): Uint8Array => {\n  const truncLeftMul8 = bytesToBigInt(bytes.slice(0, 28)) * BigInt(8);\n  return padEnd32Bytes(bigIntToBytes(truncLeftMul8));\n};\n\n/**\n * Does module 2^256.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(mod(bytes, 2^256))).\n */\nexport const mod2Pow256 = (bytes: Uint8Array): Uint8Array => {\n  return padEnd32Bytes(\n    bigIntToBytes(mod(bytesToBigInt(bytes), BigInt(2) ** BigInt(256))),\n  );\n};\n\n/**\n * Adds the left to the right.\n *\n * @param left - Left hand side Little-Endian big number.\n * @param right - Right hand side Little-Endian big number.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const add = (left: Uint8Array, right: Uint8Array): Uint8Array => {\n  const added = bytesToBigInt(left) + bytesToBigInt(right);\n  return padEnd32Bytes(bigIntToBytes(added)).slice(0, 32);\n};\n\n/**\n * Concat tag, key and childIndex.\n *\n * @param tag - Key specific tag.\n * @param key - Key.\n * @param childIndex - Child index.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const getKeyExtension = (\n  tag: number,\n  key: Uint8Array,\n  childIndex: number,\n): Uint8Array => {\n  return concatBytes([\n    new Uint8Array([tag]),\n    key,\n    numberToUint32(childIndex, true),\n  ]);\n};\n\nexport type Cip3SupportedCurve = Extract<Curve, { name: 'ed25519Bip32' }>;\n\ntype DeriveKeyBaseArgs = { childIndex: number };\n\ntype DeriveWithPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    privateKeyBytes: Uint8Array;\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: boolean;\n};\n\nconst Z_TAGS = {\n  normal: 2,\n  hardened: 0,\n};\n\n/**\n * Derive a private child key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.1,2\" in\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param options - The parameters for deriving a child key.\n * @param options.parentNode - The parent node containing private key, chain\n * code, and public key.\n * @param options.childIndex - The index of the child key.\n * @param options.isHardened - Indicates if the child key is hardened.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child key.\n */\nexport const derivePrivateKey = async (\n  { parentNode, childIndex, isHardened }: DeriveWithPrivateArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> => {\n  // extension = i >= 2^31 ? (0x00||kp||i) : (0x02||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        Z_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(Z_TAGS.normal, parentNode.publicKeyBytes, childIndex);\n\n  // entropy = Fcp(extension)\n  const entropy = await generateEntropy(\n    {\n      chainCode: parentNode.chainCodeBytes,\n      extension,\n    },\n    cryptographicFunctions,\n  );\n\n  const zl = entropy.subarray(0, 32);\n  const zr = entropy.subarray(32);\n\n  const parentKl = parentNode.privateKeyBytes.subarray(0, 32);\n  const parentKr = parentNode.privateKeyBytes.subarray(32);\n\n  // 8[ZL] + kPL\n  const childKl = add(trunc28Mul8(zl), parentKl);\n  // ZR + kPR\n  const childKr = add(zr, parentKr);\n  return concatBytes([childKl, childKr]);\n};\n\ntype DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: false;\n};\n\nconst CHAIN_CODE_TAGS = {\n  normal: 3,\n  hardened: 1,\n};\n\n/**\n * Derive a child chainCode.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.3\" in\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param options - The parameters for deriving a child chainCode.\n * @param options.parentNode - The parent node containing optionally a private\n * key, chain code, and public key.\n * @param options.childIndex - The index of the child key.\n * @param options.isHardened - Indicates if the child key is hardened.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child chainCode.\n */\nexport const deriveChainCode = async (\n  {\n    parentNode,\n    childIndex,\n    isHardened,\n  }: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> => {\n  // extension = i >= 2^31 ? (0x01||kp||i) : (0x03||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        CHAIN_CODE_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(\n        CHAIN_CODE_TAGS.normal,\n        parentNode.publicKeyBytes,\n        childIndex,\n      );\n\n  // entropy = Fcp(extension)\n  const entropy = await generateEntropy(\n    {\n      chainCode: parentNode.chainCodeBytes,\n      extension,\n    },\n    cryptographicFunctions,\n  );\n\n  return entropy.subarray(32);\n};\n\nconst PUBLIC_KEY_TAGS = {\n  normal: 2,\n};\n\ntype DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derive a public key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, D\" in\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param options - The parameters for deriving a child public key.\n * @param options.parentNode - The parent node containing chain code, and public key.\n * @param options.childIndex - The index of the child key.\n * @param options.curve - Derivation curve.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The derived child public key.\n */\nexport const derivePublicKey = async (\n  { parentNode, childIndex, curve }: DerivePublicKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> => {\n  // extension = (0x02||Ap||i)\n  const extension = getKeyExtension(\n    PUBLIC_KEY_TAGS.normal,\n    parentNode.publicKeyBytes,\n    childIndex,\n  );\n\n  // entropy = Fcp(extension)\n  const entropy = await generateEntropy(\n    {\n      chainCode: parentNode.chainCodeBytes,\n      extension,\n    },\n    cryptographicFunctions,\n  );\n\n  const zl = entropy.slice(0, 32);\n\n  // right = [8ZL] * B\n  const right = curve.getPublicKey(\n    // [8ZL]\n    trunc28Mul8(zl),\n  );\n\n  // Ai = AP + [8ZL]B,\n  return curve.publicAdd(parentNode.publicKeyBytes, right);\n};\n\ntype Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns SLIP10Node.\n */\nexport async function deriveChildKey(\n  options: Cip3DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  const { curve, node, path } = options;\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n  if (curve.name !== 'ed25519Bip32' || !node) {\n    throw new Error(\n      'Unsupported curve: Only ed25519Bip32 is supported by CIP3.',\n    );\n  }\n\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const {\n    privateKeyBytes,\n    chainCodeBytes,\n    publicKeyBytes,\n    masterFingerprint,\n    depth,\n    fingerprint: parentFingerprint,\n  } = node;\n\n  if (privateKeyBytes) {\n    const parentNode = {\n      privateKeyBytes,\n      chainCodeBytes,\n      publicKeyBytes,\n    };\n\n    const privateKey = await derivePrivateKey(\n      {\n        parentNode,\n        childIndex,\n        isHardened,\n      },\n      cryptographicFunctions,\n    );\n\n    const chainCode = await deriveChainCode(\n      {\n        parentNode,\n        childIndex,\n        isHardened,\n      },\n      cryptographicFunctions,\n    );\n\n    return SLIP10Node.fromExtendedKey(\n      {\n        privateKey: bytesToHex(privateKey),\n        chainCode: bytesToHex(chainCode),\n        masterFingerprint,\n        depth: depth + 1,\n        parentFingerprint,\n        index: actualChildIndex,\n        curve: curve.name,\n      },\n      cryptographicFunctions,\n    );\n  }\n\n  assert(\n    !isHardened,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n\n  const parentNode = {\n    chainCodeBytes,\n    publicKeyBytes,\n  };\n\n  const publicKey = await derivePublicKey(\n    {\n      parentNode,\n      childIndex,\n      isHardened: false,\n      curve,\n    },\n    cryptographicFunctions,\n  );\n\n  const chainCode = await deriveChainCode(\n    {\n      parentNode,\n      childIndex,\n      isHardened: false,\n    },\n    cryptographicFunctions,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      publicKey: bytesToHex(publicKey),\n      chainCode: bytesToHex(chainCode),\n      masterFingerprint,\n      depth: depth + 1,\n      parentFingerprint,\n      index: actualChildIndex,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n"]}